const express = require('express');
const router = express.Router();
const PDFDocument = require('pdfkit');
const createCsvWriter = require('csv-writer').createObjectCsvWriter;
const { collections, firebaseHelpers } = require('../config/firebase');
const { v4: uuidv4 } = require('uuid');

// Generate PDF report for validation result
router.post('/pdf/:validationId', async (req, res) => {
  try {
    const { validationId } = req.params;
    
    // Get validation data
    const validationDoc = await collections.validations.doc(validationId).get();
    if (!validationDoc.exists) {
      return res.status(404).json({ error: 'Validation result not found' });
    }

    const validation = validationDoc.data();
    
    // Get associated task
    const taskDoc = await collections.tasks.doc(validation.taskId).get();
    const task = taskDoc.exists ? taskDoc.data() : null;

    // Create PDF document
    const doc = new PDFDocument({ margin: 50 });
    
    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="validation-report-${validationId}.pdf"`);
    
    // Pipe PDF to response
    doc.pipe(res);

    // Add header
    doc.fontSize(24).text('QA Validation Report', { align: 'center' });
    doc.moveDown();
    
    // Add timestamp
    doc.fontSize(12).text(`Generated: ${new Date().toLocaleString()}`, { align: 'right' });
    doc.moveDown(2);

    // Task information
    if (task) {
      doc.fontSize(18).text('Task Information');
      doc.fontSize(12).text(`Title: ${task.title}`);
      doc.text(`Description: ${task.description}`);
      doc.text(`Type: ${task.taskType}`);
      doc.text(`Priority: ${task.priority}`);
      doc.text(`Assignee: ${task.assignee}`);
      doc.text(`Due Date: ${new Date(task.dueDate).toLocaleDateString()}`);
      doc.moveDown();
    }

    // Validation summary
    doc.fontSize(18).text('Validation Summary');
    doc.fontSize(12).text(`Target URL: ${validation.targetUrl}`);
    doc.text(`Verdict: ${validation.verdict}`);
    doc.text(`Score: ${validation.score}/100`);
    doc.text(`Processing Time: ${validation.processingTime}ms`);
    doc.moveDown();

    // Page information
    doc.fontSize(18).text('Page Information');
    doc.fontSize(12).text(`Title: ${validation.pageData.title}`);
    doc.text(`H1: ${validation.pageData.h1 || 'None'}`);
    doc.text(`Meta Description: ${validation.pageData.metaDescription || 'None'}`);
    doc.text(`Images: ${validation.pageData.imageCount}`);
    doc.text(`Links: ${validation.pageData.linkCount}`);
    doc.text(`Forms: ${validation.pageData.formCount}`);
    doc.text(`HTML Size: ${(validation.pageData.htmlSize / 1024).toFixed(2)} KB`);
    doc.moveDown();

    // Validation results by category
    const categories = [
      { name: 'Content Checks', checks: validation.validationResults.contentChecks },
      { name: 'SEO Checks', checks: validation.validationResults.seoChecks },
      { name: 'Accessibility Checks', checks: validation.validationResults.accessibilityChecks },
      { name: 'Performance Checks', checks: validation.validationResults.performanceChecks },
      { name: 'Link Checks', checks: validation.validationResults.linkChecks },
      { name: 'Form Checks', checks: validation.validationResults.formChecks }
    ];

    categories.forEach(category => {
      if (category.checks && category.checks.length > 0) {
        doc.fontSize(16).text(category.name);
        category.checks.forEach(check => {
          const status = check.passed ? '✅ PASS' : '❌ FAIL';
          const color = check.passed ? 'green' : 'red';
          
          doc.fontSize(10).fillColor(color).text(`${status}: ${check.description}`);
          doc.fillColor('black').text(`   Evidence: ${check.evidence}`);
          doc.text(`   Priority: ${check.priority}`);
        });
        doc.moveDown();
      }
    });

    // AI Summary
    if (validation.aiSummary) {
      doc.fontSize(16).text('AI Analysis Summary');
      doc.fontSize(10).text(validation.aiSummary);
      doc.moveDown();
    }

    // Footer
    doc.fontSize(10).text('Generated by QA Task Validator', { align: 'center' });
    
    // Finalize PDF
    doc.end();

  } catch (error) {
    console.error('❌ Error generating PDF:', error);
    res.status(500).json({
      error: 'Failed to generate PDF',
      message: 'An error occurred while generating the PDF report.'
    });
  }
});

// Generate CSV export for validation results
router.post('/csv/:validationId', async (req, res) => {
  try {
    const { validationId } = req.params;
    
    // Get validation data
    const validationDoc = await collections.validations.doc(validationId).get();
    if (!validationDoc.exists) {
      return res.status(404).json({ error: 'Validation result not found' });
    }

    const validation = validationDoc.data();
    
    // Get associated task
    const taskDoc = await collections.tasks.doc(validation.taskId).get();
    const task = taskDoc.exists ? taskDoc.data() : null;

    // Prepare CSV data
    const csvData = [];
    
    // Add validation summary
    csvData.push({
      'Category': 'Validation Summary',
      'Field': 'Verdict',
      'Value': validation.verdict,
      'Status': ''
    });
    csvData.push({
      'Category': 'Validation Summary',
      'Field': 'Score',
      'Value': `${validation.score}/100`,
      'Status': ''
    });
    csvData.push({
      'Category': 'Validation Summary',
      'Field': 'Target URL',
      'Value': validation.targetUrl,
      'Status': ''
    });

    // Add task information
    if (task) {
      csvData.push({
        'Category': 'Task Information',
        'Field': 'Title',
        'Value': task.title,
        'Status': ''
      });
      csvData.push({
        'Category': 'Task Information',
        'Field': 'Type',
        'Value': task.taskType,
        'Status': ''
      });
      csvData.push({
        'Category': 'Task Information',
        'Field': 'Priority',
        'Value': task.priority,
        'Status': ''
      });
    }

    // Add page information
    csvData.push({
      'Category': 'Page Information',
      'Field': 'Title',
      'Value': validation.pageData.title,
      'Status': ''
    });
    csvData.push({
      'Category': 'Page Information',
      'Field': 'H1',
      'Value': validation.pageData.h1 || 'None',
      'Status': ''
    });

    // Add validation checks
    const allChecks = [
      ...validation.validationResults.contentChecks,
      ...validation.validationResults.seoChecks,
      ...validation.validationResults.accessibilityChecks,
      ...validation.validationResults.performanceChecks,
      ...validation.validationResults.linkChecks,
      ...validation.validationResults.formChecks
    ];

    allChecks.forEach(check => {
      csvData.push({
        'Category': 'Validation Check',
        'Field': check.description,
        'Value': check.evidence,
        'Status': check.passed ? 'PASS' : 'FAIL'
      });
    });

    // Set response headers
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="validation-results-${validationId}.csv"`);

    // Create CSV writer
    const csvWriter = createCsvWriter({
      path: 'temp.csv', // This won't actually create a file
      header: [
        { id: 'Category', title: 'Category' },
        { id: 'Field', title: 'Field' },
        { id: 'Value', title: 'Value' },
        { id: 'Status', title: 'Status' }
      ]
    });

    // Convert to CSV string and send
    const csvString = await csvWriter.stringifyRecords(csvData);
    res.send(csvString);

  } catch (error) {
    console.error('❌ Error generating CSV:', error);
    res.status(500).json({
      error: 'Failed to generate CSV',
      message: 'An error occurred while generating the CSV export.'
    });
  }
});

// Generate bug ticket
router.post('/bug-ticket/:validationId', async (req, res) => {
  try {
    const { validationId } = req.params;
    
    // Get validation data
    const validationDoc = await collections.validations.doc(validationId).get();
    if (!validationDoc.exists) {
      return res.status(404).json({ error: 'Validation result not found' });
    }

    const validation = validationDoc.data();
    
    // Get associated task
    const taskDoc = await collections.tasks.doc(validation.taskId).get();
    const task = taskDoc.exists ? taskDoc.data() : null;

    // Generate bug ticket ID
    const bugId = `BUG-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`;

    // Prepare bug ticket data
    const bugTicket = {
      id: bugId,
      title: `[${validation.verdict.toUpperCase()}] ${task ? task.title : 'Validation Failed'}`,
      severity: validation.verdict === 'Fail' ? 'High' : 'Medium',
      priority: validation.priority || 'Medium',
      status: 'Open',
      assignee: task ? task.assignee : 'Unassigned',
      reporter: 'QA Automation System',
      createdAt: new Date().toISOString(),
      targetUrl: validation.targetUrl,
      acceptanceCriteria: validation.acceptanceCriteria,
      validationScore: validation.score,
      validationVerdict: validation.verdict,
      failedChecks: [],
      stepsToReproduce: [
        `Navigate to: ${validation.targetUrl}`,
        'Review the page content and functionality',
        'Check against the acceptance criteria',
        'Review validation results for specific failures'
      ],
      expectedResult: 'Page should meet all acceptance criteria and pass validation checks',
      actualResult: `Page failed validation with score ${validation.score}/100 - Verdict: ${validation.verdict}`,
      evidence: [],
      environment: 'Automated QA Validation',
      attachments: [],
      notes: validation.aiSummary || 'No AI analysis available'
    };

    // Add failed checks
    const allChecks = [
      ...validation.validationResults.contentChecks,
      ...validation.validationResults.seoChecks,
      ...validation.validationResults.accessibilityChecks,
      ...validation.validationResults.performanceChecks,
      ...validation.validationResults.linkChecks,
      ...validation.validationResults.formChecks
    ];

    allChecks.forEach(check => {
      if (!check.passed) {
        bugTicket.failedChecks.push({
          type: check.type,
          description: check.description,
          evidence: check.evidence,
          priority: check.priority
        });
        
        bugTicket.evidence.push(`${check.description}: ${check.evidence}`);
      }
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', `attachment; filename="bug-ticket-${bugId}.json"`);

    res.status(200).json({
      success: true,
      message: 'Bug ticket generated successfully',
      bugTicket
    });

  } catch (error) {
    console.error('❌ Error generating bug ticket:', error);
    res.status(500).json({
      error: 'Failed to generate bug ticket',
      message: 'An error occurred while generating the bug ticket.'
    });
  }
});

// Generate comprehensive report (all formats)
router.post('/comprehensive/:validationId', async (req, res) => {
  try {
    const { validationId } = req.params;
    
    // Get validation data
    const validationDoc = await collections.validations.doc(validationId).get();
    if (!validationDoc.exists) {
      return res.status(404).json({ error: 'Validation result not found' });
    }

    const validation = validationDoc.data();
    
    // Get associated task
    const taskDoc = await collections.tasks.doc(validation.taskId).get();
    const task = taskDoc.exists ? taskDoc.data() : null;

    // Generate report ID
    const reportId = uuidv4();

    // Create comprehensive report
    const report = {
      id: reportId,
      validationId,
      taskId: validation.taskId,
      generatedAt: new Date().toISOString(),
      summary: {
        verdict: validation.verdict,
        score: validation.score,
        targetUrl: validation.targetUrl,
        processingTime: validation.processingTime
      },
      task: task ? {
        title: task.title,
        description: task.description,
        type: task.taskType,
        priority: task.priority,
        assignee: task.assignee,
        dueDate: task.dueDate
      } : null,
      pageData: validation.pageData,
      validationResults: validation.validationResults,
      aiSummary: validation.aiSummary,
      exportUrls: {
        pdf: `/api/export/pdf/${validationId}`,
        csv: `/api/export/csv/${validationId}`,
        bugTicket: `/api/export/bug-ticket/${validationId}`
      }
    };

    // Store report in Firestore
    await collections.shares.doc(reportId).set({
      type: 'comprehensive_report',
      data: report,
      createdAt: firebaseHelpers.isoToTimestamp(new Date().toISOString()),
      expiresAt: firebaseHelpers.isoToTimestamp(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()) // 7 days
    });

    res.status(200).json({
      success: true,
      message: 'Comprehensive report generated successfully',
      report,
      shareUrl: `/api/export/share/${reportId}`
    });

  } catch (error) {
    console.error('❌ Error generating comprehensive report:', error);
    res.status(500).json({
      error: 'Failed to generate comprehensive report',
      message: 'An error occurred while generating the comprehensive report.'
    });
  }
});

// Share report via public link
router.get('/share/:reportId', async (req, res) => {
  try {
    const { reportId } = req.params;
    
    const reportDoc = await collections.shares.doc(reportId).get();
    if (!reportDoc.exists) {
      return res.status(404).json({ error: 'Report not found' });
    }

    const report = reportDoc.data();
    
    // Check if report has expired
    if (report.expiresAt && new Date() > report.expiresAt.toDate()) {
      return res.status(410).json({ error: 'Report has expired' });
    }

    res.status(200).json({
      success: true,
      report: report.data
    });

  } catch (error) {
    console.error('❌ Error accessing shared report:', error);
    res.status(500).json({
      error: 'Failed to access shared report',
      message: 'An error occurred while accessing the shared report.'
    });
  }
});

module.exports = router;
